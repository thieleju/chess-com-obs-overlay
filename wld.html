<!doctype html>
<html lang="en">
  <head>
    <title></title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"
      integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm"
      crossorigin="anonymous"
    />

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Nunito:wght@400;700&display=swap");

      body {
        padding-top: 10px;
        padding-left: 10px;
        height: 100vh;
        width: 100vw;
        color: white;
        #background-color: transparent !important;
        background-color: #1a1a1a;
        font-family: "NuNito", sans-serif;
        line-height: 1;
        font-weight: bold;
      }

      .wld {
        font-size: 100px;
      }

      .inline {
        display: inline;
      }

      .rating {
        font-size: 50px;
      }

      .form-control {
        width: 300px;
      }

      .errorMessage {
        font-size: 10px;
        color: #f44336;
      }

      .successMessage {
        font-size: 10px;
        color: #4caf50;
      }

      .btn.active {
        background-color: #004a99 !important;
        border-color: #004a99 !important;
      }
    </style>
  </head>
  <body>
    <div id="global">
      <div class="wld">
        <div class="inline" id="wins">0</div>
        /
        <div class="inline" id="losses">0</div>
        /
        <div class="inline" id="draws">0</div>
      </div>
      <div class="rating">
        <span id="ratingLabel">Elo:</span>
        <span id="ratingDiff">+0</span>
      </div>
      <span id="errorMessage" class="errorMessage"></span>
      <span id="successMessage" class="successMessage"></span>
    </div>
    <!-- Hide buttons by default -->
    <div id="editMode" style="display: none">
      <button id="rapid" class="btn btn-primary active" type="button">
        Rapid
      </button>
      <button id="blitz" class="btn btn-primary" type="button">Blitz</button>
      <button id="bullet" class="btn btn-primary" type="button">Bullet</button>
      <button id="reset" class="btn btn-secondary" type="button">
        Reset All
      </button>
      <div class="mt-1">
        <!-- Input field for username -->
        <input
          type="text"
          class="form-control"
          id="usernameInput"
          value=""
          placeholder="Enter your chess.com username"
        />
      </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/luxon@3.5.0/build/global/luxon.min.js"></script>
    <script type="text/javascript">
      const COLOR_GREEN = "#4caf50"
      const COLOR_RED = "#f44336"
      const COLOR_WHITE = "#ffffff"
      const ANIMATION_DURATION = 700
      const CHESS_COM_TIMEZONE = "America/Los_Angeles"
      const CHESS_API_URL = "https://api.chess.com/pub/player"
      // TODO: Update according to https://support.chess.com/en/articles/9650547-published-data-api
      const USER_AGENT =
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.3"
      const INTERVAL_MS = 6000
      const FETCH_HARD_TIMEOUT = 3000
      const STATE_DEFAULT = {
        username: "",
        gameMode: "rapid",
        editMode: false,
        modes: {
          rapid: {
            score: { wins: 0, losses: 0, draws: 0 },
            initialRating: null,
            lastRatingDiff: 0
          },
          blitz: {
            score: { wins: 0, losses: 0, draws: 0 },
            initialRating: null,
            lastRatingDiff: 0
          },
          bullet: {
            score: { wins: 0, losses: 0, draws: 0 },
            initialRating: null,
            lastRatingDiff: 0
          }
        }
      }

      // Set to remember already processed games
      const processedGameUUIDs = new Set()
      // Only games that end after this time will be considered
      let scriptStartTime = Math.floor(Date.now() / 1000)
      let interval = null
      let isRunning = false
      let state = JSON.parse(JSON.stringify(STATE_DEFAULT))
      let elements = getDomElements()

      function getDomElements() {
        return {
          wins: document.getElementById("wins"),
          losses: document.getElementById("losses"),
          draws: document.getElementById("draws"),
          ratingDiff: document.getElementById("ratingDiff"),
          rating: document.querySelector(".rating"),
          editMode: document.getElementById("editMode"),
          reset: document.getElementById("reset"),
          global: document.getElementById("global"),
          errorMessage: document.getElementById("errorMessage"),
          successMessage: document.getElementById("successMessage"),
          usernameInput: document.getElementById("usernameInput"),
          modes: {
            rapid: document.getElementById("rapid"),
            blitz: document.getElementById("blitz"),
            bullet: document.getElementById("bullet")
          }
        }
      }

      async function fetchData(url) {
        // Trigger errors for testing
        // if (Math.random() < 0.2) throw new Error("Random error")

        const response = await fetch(url, {
          signal: AbortSignal.timeout(FETCH_HARD_TIMEOUT),
          headers: {
            "User-Agent": USER_AGENT
          }
        })

        if (!response.ok)
          throw new Error(`HTTP Error: ${response.status} for URL: ${url}`)

        const data = await response.json()
        if (!data) throw new Error(`No data received for URL: ${url}`)

        return data
      }

      async function fetchAllCurrentRatings() {
        const url = `${CHESS_API_URL}/${state.username}/stats`
        const data = await fetchData(url)
        if (!data) return null
        return {
          rapid: data?.chess_rapid?.last?.rating,
          blitz: data?.chess_blitz?.last?.rating,
          bullet: data?.chess_bullet?.last?.rating
        }
      }

      function getGamesUrl(username) {
        const { DateTime } = luxon
        const date = DateTime.local().setZone(CHESS_COM_TIMEZONE)
        const month = date.month.toString().padStart(2, "0")
        return `${CHESS_API_URL}/${username}/games/${date.year}/${month}`
      }

      async function fetchGames() {
        const url = getGamesUrl(state.username)
        const data = await fetchData(url)
        if (!data || data.message) return null
        // Sort games by end_time in descending order
        return data?.games?.sort((a, b) => b.end_time - a.end_time) || []
      }

      function mapResult(result) {
        switch (result) {
          case "win":
            return 1
          case "draw":
            return 0.5
          default:
            // Everything else is a loss
            return 0
        }
      }

      function getScore(games) {
        const newScore = state.modes[state.gameMode].score
        if (!games || games.length === 0) return newScore

        // Only consider games that ended after the start time and match the current mode
        const gamesToCheck = games.filter(
          (game) =>
            game.end_time > scriptStartTime &&
            game.time_class === state.gameMode &&
            // skip processed games
            !processedGameUUIDs.has(game.uuid)
        )

        for (let i = 0; i < gamesToCheck.length; i++) {
          const game = gamesToCheck[i]

          let userResult = null
          if (
            game.white.username.toLowerCase() === state.username.toLowerCase()
          ) {
            userResult = mapResult(game.white.result)
          } else if (
            game.black.username.toLowerCase() === state.username.toLowerCase()
          ) {
            userResult = mapResult(game.black.result)
          } else {
            continue
          }

          if (userResult === 1) newScore.wins += 1
          else if (userResult === 0) newScore.losses += 1
          else if (userResult === 0.5) newScore.draws += 1

          // Mark the game as processed
          processedGameUUIDs.add(game.uuid)
        }
        return newScore
      }

      async function updateUI(games) {
        // Update wld
        const score = getScore(games)
        setWld(score.wins, score.losses, score.draws)

        // Calculate rating diff
        const allCurrentRatings = await fetchAllCurrentRatings()
        if (!allCurrentRatings) return

        const ratingDiff =
          allCurrentRatings[state.gameMode] -
          state.modes[state.gameMode].initialRating

        // Additional checks to prevent NaN and duplicate animations
        if (isNaN(ratingDiff)) return
        if (ratingDiff === state.modes[state.gameMode].lastRatingDiff) return

        animateEloDiff(ratingDiff, state.modes[state.gameMode].lastRatingDiff)
        state.modes[state.gameMode].lastRatingDiff = ratingDiff
      }

      function animateEloDiff(newEloDiff, lastRatingDiff) {
        const start = performance.now()
        const initialDiff = lastRatingDiff

        requestAnimationFrame(function animate(time) {
          const timeFraction = Math.min((time - start) / ANIMATION_DURATION, 1)
          const ratingDiff = Math.floor(
            initialDiff + timeFraction * (newEloDiff - initialDiff)
          )

          setRatingDiff(ratingDiff)

          if (timeFraction < 1) requestAnimationFrame(animate)
        })
      }

      function setRatingDiff(ratingDiff) {
        if (ratingDiff === 0) {
          elements.ratingDiff.innerHTML = `+${ratingDiff}`
          elements.ratingDiff.style.color = COLOR_WHITE
        } else if (ratingDiff > 0) {
          elements.ratingDiff.innerHTML = `+${ratingDiff}`
          elements.ratingDiff.style.color = COLOR_GREEN
        } else if (ratingDiff < 0) {
          elements.ratingDiff.innerHTML = `${ratingDiff}`
          elements.ratingDiff.style.color = COLOR_RED
        }
      }

      function setWld(wins, losses, draws) {
        elements.wins.innerHTML = wins
        elements.losses.innerHTML = losses
        elements.draws.innerHTML = draws
      }

      function switchEditMode(newMode) {
        state.editMode = newMode
        elements.editMode.style.display = state.editMode ? "block" : "none"
      }

      // ########################################################
      // #################### INITIALIZATION ####################
      // ########################################################
      async function init() {
        try {
          const [games, allCurrentRatings] = await Promise.all([
            fetchGames(),
            fetchAllCurrentRatings()
          ])

          // Set the initial rating value for each mode (no lastGameId)
          for (const mode of Object.keys(state.modes)) {
            state.modes[mode].initialRating = allCurrentRatings[mode]
          }

          await updateUI(games)
          elements.errorMessage.innerHTML = ""
          console.log("Initialized State", state)
        } catch (err) {
          handleFetchError(err)
        }
      }

      // ###################################################
      // #################### MAIN LOOP ####################
      // ###################################################
      function startInterval() {
        interval = setInterval(async () => {
          // skip is username is empty
          if (!state.username) return

          // Skip if edit mode is active or if the interval is already running
          if (state.editMode || isRunning) return

          isRunning = true

          let games = null
          try {
            games = await fetchGames()
          } catch (err) {
            handleFetchError(err)
            isRunning = false
            return
          }
          await updateUI(games)
          isRunning = false
        }, INTERVAL_MS)
      }

      // #######################################################
      // #################### SCRIPT STARTS ####################
      // #######################################################
      async function start() {
        await init()

        // Reset button event listener
        elements.reset.addEventListener("click", async () => {
          console.log("Resetting stats")

          showSuccessMessage("Resetting stats...")

          // Disable reset button while reinitialization is running (looking at you, double clickers)
          elements.reset.disabled = true

          // Reset All
          resetAllStats()
          // Set username
          state.username = elements.usernameInput.value

          await init()
          elements.reset.disabled = false
        })

        // Event listener for game mode change
        for (const mode in elements.modes) {
          elements.modes[mode].addEventListener("click", () => {
            console.log("Set game mode to", mode, state.modes[mode])

            state.gameMode = mode
            switchEditMode(false)

            // Update rating diff and WLD immediately on mode change
            setRatingDiff(state.modes[state.gameMode].lastRatingDiff)
            setWld(
              state.modes[state.gameMode].score.wins,
              state.modes[state.gameMode].score.losses,
              state.modes[state.gameMode].score.draws
            )

            // Change which button is active
            for (const mode in elements.modes) {
              elements.modes[mode].classList.remove("active")
            }
            elements.modes[mode].classList.add("active")
            showSuccessMessage(`Switched to ${mode} mode`)
          })
        }

        // Event listener for username change
        elements.usernameInput.addEventListener("change", (event) => {
          console.log("Setting username to", event.target.value)

          // Reset state
          resetAllStats()

          // Set the new username
          state.username = event.target.value

          showSuccessMessage(`Set username to ${state.username}`)

          init()
        })

        // Global event listener for switching edit mode
        elements.global.addEventListener("click", () =>
          switchEditMode(!state.editMode)
        )

        // Start the update interval
        startInterval()
      }

      function showSuccessMessage(message) {
        elements.successMessage.innerHTML = message
        setTimeout(() => {
          elements.successMessage.innerHTML = ""
        }, 1000)
      }

      function resetAllStats() {
        switchEditMode(false)

        // Reset the state
        state = JSON.parse(JSON.stringify(STATE_DEFAULT))
        elements = getDomElements()
        setWld(0, 0, 0)
        setRatingDiff(0)

        // Reset script start time
        scriptStartTime = Math.floor(Date.now() / 1000)

        // Clear processed games
        processedGameUUIDs.clear()

        // Change which button is active
        for (const mode in elements.modes) {
          elements.modes[mode].classList.remove("active")
        }

        elements.modes[state.gameMode].classList.add("active")
      }

      function handleFetchError(err) {
        if (err.name === "AbortError") {
          console.error("Fetch timeout:", err)
          // elements.errorMessage.innerHTML = `Request timed out. Retrying...`
        } else if (err.message.includes("HTTP Error: 404")) {
          elements.errorMessage.innerHTML =
            state.username === ""
              ? "Enter your chess.com username"
              : `User '${state.username}' not found`
        } else {
          // Throw global error
          throw err
        }
      }

      async function handleGlobalError(event) {
        console.error("Unhandled error:", event.error || event.reason || event)
        elements.errorMessage.innerHTML =
          "Something bad happened, retrying after 5s..."
        await new Promise((resolve) => setTimeout(resolve, 5000))

        // Remove event listeners
        elements.reset.removeEventListener("click", () => {})
        elements.reset.disabled = false
        elements.global.removeEventListener("click", () => {})
        for (const mode in elements.modes) {
          elements.modes[mode].removeEventListener("click", () => {})
        }
        if (interval) clearInterval(interval)

        // Reset state
        resetAllStats()
        // Set username
        state.username = elements.usernameInput.value

        isRunning = false
        elements.errorMessage.innerHTML = ""
        await start()
      }

      window.addEventListener("error", function (event) {
        handleGlobalError(event)
      })

      window.addEventListener("unhandledrejection", function (event) {
        handleGlobalError(event)
      })

      window.addEventListener("beforeunload", () => {
        console.log("Unloading page and clearing interval...")
        clearInterval(interval)
      })

      // START
      start()
    </script>
  </body>
</html>
